{"meta":{"title":"云淡风轻","subtitle":"一个安静的角落","description":"隐约雷鸣，阴霾天空，但盼风雨来，能留你在此","author":"云淡风轻","url":"https://ioliu.cn","root":"/"},"pages":[{"title":"Sorry , Page Not Found","date":"2015-05-08T09:50:17.000Z","updated":"2024-03-26T13:23:43.422Z","comments":false,"path":"404.html","permalink":"https://ioliu.cn/404.html","excerpt":"","text":"404 SORRY , PAGE NOT FOUND 首页&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上页"},{"title":"404 Not Found：该页无法显示","date":"2024-03-26T13:23:43.422Z","updated":"2024-03-26T13:23:43.422Z","comments":false,"path":"/404.html","permalink":"https://ioliu.cn/404.html","excerpt":"","text":""},{"title":"关于","date":"2024-03-26T13:23:43.422Z","updated":"2024-03-26T13:23:43.422Z","comments":false,"path":"about/index.html","permalink":"https://ioliu.cn/about/index.html","excerpt":"","text":"这个人很懒，什么都没有留下！"},{"title":"书单","date":"2024-03-26T13:23:43.422Z","updated":"2024-03-26T13:23:43.422Z","comments":false,"path":"books/index.html","permalink":"https://ioliu.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-03-26T13:23:43.422Z","updated":"2024-03-26T13:23:43.422Z","comments":false,"path":"categories/index.html","permalink":"https://ioliu.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-03-26T13:23:43.426Z","updated":"2024-03-26T13:23:43.426Z","comments":true,"path":"links/index.html","permalink":"https://ioliu.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2024-03-26T13:23:43.426Z","updated":"2024-03-26T13:23:43.426Z","comments":false,"path":"repository/index.html","permalink":"https://ioliu.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-03-26T13:23:43.426Z","updated":"2024-03-26T13:23:43.426Z","comments":false,"path":"tags/index.html","permalink":"https://ioliu.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"在Debian 11上升级内核并启用BBR加速","slug":"upgrade-debian-kernel-version","date":"2024-03-23T14:53:34.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2024/upgrade-debian-kernel-version/","permalink":"https://ioliu.cn/2024/upgrade-debian-kernel-version/","excerpt":"","text":"如果你正在使用Debian 11并且希望提升你的系统性能，升级到最新的内核版本并启用BBR加速可能是一个不错的选择。以下是一篇指南，将带你了解如何安全地升级内核以及如何启用BBR来优化你的网络连接。 升级到新版内核第一步：备份你的系统在进行任何重大系统更改之前，备份是非常重要的。你可以使用如Timeshift等工具来备份你的系统。 第二步：修改软件源为了安装最新的内核，我们可能需要添加Debian的Backports源。以下是添加Backports源的步骤： 打开/etc/apt/sources.list文件： 1sudo nano /etc/apt/sources.list 在文件末尾添加以下行： 12deb http://deb.debian.org/debian bullseye-backports main contrib non-freedeb-src http://deb.debian.org/debian bullseye-backports main contrib non-free 保存并退出编辑器。 更新软件包列表： 1sudo apt update 第三步：安装新内核使用Backports源安装新内核： 12sudo apt-get -t bullseye-backports install linux-image-6.x.x-x-amd64sudo apt-get -t bullseye-backports install linux-headers-6.x.x-x-amd64 请确保替换命令中的版本号为你想要安装的实际版本。 第四步：更新GRUB并重启安装完新内核后，更新GRUB： 1sudo update-grub 然后重启你的系统： 1sudo reboot 清除旧内核第一步：列出当前内核使用以下命令查看当前安装的内核： 12dpkg --list | grep linux-imagedpkg --list | grep linux-headers 第二步：删除旧内核选择你不再需要的内核版本，并使用apt-get purge命令进行删除： 12sudo apt-get purge linux-image-5.x.x-x-amd64sudo apt-get purge linux-headers-5.x.x-x-amd64 第三步：更新GRUB再次更新GRUB配置： 1sudo update-grub 启用BBR加速第一步：加载TCP BBR模块编辑/etc/sysctl.conf文件，在文件末尾添加以下两行： 12net.core.default_qdisc=fqnet.ipv4.tcp_congestion_control=bbr 第二步：应用新的系统配置应用新的配置： 1sudo sysctl -p 第三步：验证BBR是否启用运行以下命令： 1sysctl net.ipv4.tcp_congestion_control 如果输出显示bbr，则BBR已启用。 结语现在，你的Debian 11系统应该运行在最新的内核上，并且已经启用了BBR加速。这将帮助你提高系统的整体性能和网络连接的速度。请确保在执行以上操作时仔细检查，并始终保持系统的备份。 参考 Debian Backports Instructions Timeshift on GitHub Google BBR Congestion Control Algorithm","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ioliu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"bbr","slug":"bbr","permalink":"https://ioliu.cn/tags/bbr/"},{"name":"linux","slug":"linux","permalink":"https://ioliu.cn/tags/linux/"}]},{"title":"Git中的一些骚操作","slug":"git-command-backup","date":"2017-11-10T06:30:25.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2017/git-command-backup/","permalink":"https://ioliu.cn/2017/git-command-backup/","excerpt":"","text":"最近因为Valine，所以经常用到Git。当然，工作中也有用到，但基本上是用的图形化。 这里最Git的相关操作命令做个备份，以备不时之需。 可能不定时更新。 配置自动换行1git config --global core.autocrlf input # 提交时自动将换行符转成lf 多账号配置SSH修改~/.ssh/config文件(Windows平台) 1234567891011121314151617181920# 配置 Github.comHost github.com HostName github.com IdentityFile C:\\\\path\\\\to\\\\.ssh\\\\id_rsa_github PreferredAuthentications publickey User YourName# 配置 Coding.netHost git.coding.net HostName git.coding.net IdentityFile C:\\\\path\\\\to\\\\.ssh\\\\id_rsa_coding PreferredAuthentications publickey User YourName# 配置 Gitee.comHost gitee.com HostName gitee.com IdentityFile C:\\\\path\\\\to\\\\.ssh\\\\id_rsa_gitee PreferredAuthentications publickey User YourName pull 强制覆盖本地文件12git fetch --all git reset --hard origin/master push 强制覆盖远程文件1git push -f origin master 保持fork之后的项目和上游同步团队协作，为了规范，一般都是fork组织的仓库到自己帐号下，再提交pr，组织的仓库一直保持更新，下面介绍如何保持自己fork之后的仓库与上游仓库同步。 下面以我 fork 团队的博客仓库为例 点击 fork 组织仓库到自己帐号下，然后就可以在自己的帐号下 clone 相应的仓库 使用 git remote -v 查看当前的远程仓库地址，输出如下： 12origin git@github.com:ibrother/staticblog.github.io.git (fetch)origin git@github.com:ibrother/staticblog.github.io.git (push) 可以看到从自己帐号 clone 下来的仓库，远程仓库地址是与自己的远程仓库绑定的（这不是废话吗） 接下来运行: 1git remote add upstream https://github.com/staticblog/staticblog.github.io.git 这条命令就算添加一个别名为 upstream（上游）的地址，指向之前 fork 的原仓库地址。git remote -v 输出如下： 1234origin git@github.com:ibrother/staticblog.github.io.git (fetch)origin git@github.com:ibrother/staticblog.github.io.git (push)upstream https://github.com/staticblog/staticblog.github.io.git (fetch)upstream https://github.com/staticblog/staticblog.github.io.git (push) 之后运行下面几条命令，就可以保持本地仓库和上游仓库同步了 123git fetch upstreamgit checkout mastergit merge upstream/master 接着就是熟悉的推送本地仓库到远程仓库 1git push origin master From staticblog .","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ioliu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ioliu.cn/tags/Git/"},{"name":"Command","slug":"Command","permalink":"https://ioliu.cn/tags/Command/"}]},{"title":"Valine -- 一款极简的评论系统","slug":"add-valine-comments-to-your-blog","date":"2017-08-07T06:30:25.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2017/add-valine-comments-to-your-blog/","permalink":"https://ioliu.cn/2017/add-valine-comments-to-your-blog/","excerpt":"","text":"Valine - 一款极简的无后端评论系统. 2017年6月1日，在你等超龄儿童欢度节日的时候，多说躺下了。2017年8月1日，不甘寂寞的网易云跟帖也跟多说随风而去了。 2017年8月7日，一款基于Leancloud的极简风评论系统诞生：Valine。 食用方法获取 APP ID 和 APP KEY 点击这里登录或注册Leancloud 点这里创建应用，应用名看个人喜好。 选择刚刚创建的应用&gt;设置&gt;选择应用 Key，然后你就能看到你的APP ID和APP KEY了，参考下图： 为了您的数据安全，请填写应用&gt;设置&gt;安全设置中的Web 安全域名，如下图： 页面中的设置页面中的食用方法炒鸡简单，来来来，我们用代码说话： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Valine - A simple comment system based on Leancloud.&lt;/title&gt; &lt;!--Leancloud 操作库:--&gt; &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt; &lt;!--Valine 的核心代码库:--&gt; &lt;script src=&quot;./dist/Valine.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;comment&quot;&gt;&lt;/div&gt; &lt;script&gt; new Valine(&#123; // AV 对象来自上面引入av-min.js(老司机们不要开车➳♡゛扎心了老铁) av: AV, el: &#x27;.comment&#x27;, // app_id: &#x27;Your APP ID&#x27;, // 这里填写上面得到的APP ID app_key: &#x27;Your APP KEY&#x27;, // 这里填写上面得到的APP KEY placeholder: &#x27;ヾﾉ≧∀≦)o来啊，快活啊!&#x27; // [v1.0.7 new]留言框占位提示文字 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 看吧，我是不是没说大话(_(:з」∠)_一本正经的胡说八道)。 评论数据管理插播一下，关于评论数据管理，请自行登录Leancloud应用管理。具体步骤：登录&gt;选择你创建的应用&gt;存储&gt;选择ClassComment，然后就可以尽情的发挥你的权利啦(～￣▽￣)～ 更多配置信息请移步：https://valine.js.org –EOF–","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ioliu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Valine","slug":"Valine","permalink":"https://ioliu.cn/tags/Valine/"},{"name":"Comment System","slug":"Comment-System","permalink":"https://ioliu.cn/tags/Comment-System/"},{"name":"评论系统","slug":"评论系统","permalink":"https://ioliu.cn/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"}]},{"title":"不同的国家/地区与语言缩写代码","slug":"country-city-and-language","date":"2017-06-29T07:30:08.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2017/country-city-and-language/","permalink":"https://ioliu.cn/2017/country-city-and-language/","excerpt":"","text":"国家&#x2F;地区 语言代码 国家地区 语言代码 简体中文(中国) zh-cn 简体中文(台湾地区) zh-tw 繁体中文(香港) zh-hk 英语(香港) en-hk 英语(美国) en-us 英语(英国) en-gb 英语(全球) en-ww 英语(加拿大) en-ca 英语(澳大利亚) en-au 英语(爱尔兰) en-ie 英语(芬兰) en-fi 芬兰语(芬兰) fi-fi 英语(丹麦) en-dk 丹麦语(丹麦) da-dk 英语(以色列) en-il 希伯来语(以色列) he-il 英语(南非) en-za 英语(印度) en-in 英语(挪威) en-no 英语(新加坡) en-sg 英语(新西兰) en-nz 英语(印度尼西亚) en-id 英语(菲律宾) en-ph 英语(泰国) en-th 英语(马来西亚) en-my 英语(阿拉伯) en-xa 韩文(韩国) ko-kr 日语(日本) ja-jp 荷兰语(荷兰) nl-nl 荷兰语(比利时) nl-be 葡萄牙语(葡萄牙) pt-pt 葡萄牙语(巴西) pt-br 法语(法国) fr-fr 法语(卢森堡) fr-lu 法语(瑞士) fr-ch 法语(比利时) fr-be 法语(加拿大) fr-ca 西班牙语(拉丁美洲) es-la 西班牙语(西班牙) es-es 西班牙语(阿根廷) es-ar 西班牙语(美国) es-us 西班牙语(墨西哥) es-mx 西班牙语(哥伦比亚) es-co 西班牙语(波多黎各) es-pr 德语(德国) de-de 德语(奥地利) de-at 德语(瑞士) de-ch 俄语(俄罗斯) ru-ru 意大利语(意大利) it-it 希腊语(希腊) el-gr 挪威语(挪威) no-no 匈牙利语(匈牙利) hu-hu 土耳其语(土耳其) tr-tr 捷克语(捷克共和国) cs-cz 斯洛文尼亚语 sl-sl 波兰语(波兰) pl-pl 瑞典语(瑞典) sv-se 西班牙语 (智利) es-cl","categories":[{"name":"其他","slug":"其他","permalink":"https://ioliu.cn/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"国家/地区","slug":"国家-地区","permalink":"https://ioliu.cn/tags/%E5%9B%BD%E5%AE%B6-%E5%9C%B0%E5%8C%BA/"},{"name":"语言缩写","slug":"语言缩写","permalink":"https://ioliu.cn/tags/%E8%AF%AD%E8%A8%80%E7%BC%A9%E5%86%99/"}]},{"title":"从删库到跑路 -- MySql 不算初体验的初体验","slug":"mysql-tutorial","date":"2017-03-24T03:00:25.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2017/mysql-tutorial/","permalink":"https://ioliu.cn/2017/mysql-tutorial/","excerpt":"","text":"最近准备找时间把bing壁纸项目重构，但由于虚拟主机快要过期了，所以目前的首要任务是将数据库从阿里云的虚拟主机转移到我自己的服务器上。 因为多年前学过SQLServer、Oracle、MySql等数据库，但许久未用，技艺生疏，所以这里是不算初体验的初体验。 本文将执行三步走计划： 安装 登录 使用 安装在Debian上安装MySql很简单，运行如下命令就基本OK： 1$ apt-get install mysql-server mysql-client 其中mysql-server是服务器程序，mysql-client是客户端程序。安装过程中会有如下提示，需要设置mysql数据库密码；输入要设置的密码后，回车即可继续安装。 如果出现Unable to locate package mysql-server等错误，请先执行apt-get update后重试。 登录安装成功后，mysql会自动启动，可以通过ps -ef | grep mysql查看mysql是否运行。登陆mysql: 123# login$ mysql -u root -pEnter password: # 输入密码 其中-u后跟的是用户名，-p要求输入密码，回车后在输入密码处输入密码。 查看数据库show databases;： 12345678910$ mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.00 sec) 使用创建数据库12$ mysql&gt; create database DB_name;Query OK, 1 row affected (0.05 sec) 查看刚刚创建的数据库1234567891011$ mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || DB_name || mysql || performance_schema || sys |+--------------------+5 rows in set (0.00 sec) 使用刚刚创建的数据库12$ mysql&gt; use DB_name;Database changed 创建表12345$ mysql&gt; CREATE TABLE IF NOT EXISTS person ( number INT(11), name VARCHAR(255), birthday DATE ); 查看表1234567$ mysql&gt; SHOW CREATE table person;CREATE TABLE `person` ( `number` int(11) DEFAULT NULL, `name` varchar(255) DEFAULT NULL, `birthday` date DEFAULT NULL) ENGINE=MyISAM DEFAULT CHARSET=utf8; 查看表的所有列12345678$ mysql&gt; SHOW FULL COLUMNS from person;+----------+--------------+-----------------+------+-----+---------+-------+---------------------------------+---------+| Field | Type | Collation | Null | Key | Default | Extra | Privileges | Comment |+----------+--------------+-----------------+------+-----+---------+-------+---------------------------------+---------+| number | int(11) | NULL | YES | | NULL | | select,insert,update,references | || name | varchar(255) | utf8_general_ci | YES | | NULL | | select,insert,update,references | || birthday | date | NULL | YES | | NULL | | select,insert,update,references | |+----------+--------------+-----------------+------+-----+---------+-------+---------------------------------+---------+ 创建临时表12345$ mysql&gt; CREATE TEMPORARY TABLE temp_person ( number INT(11), name VARCHAR(255), birthday DATE ); 删除表123$ mysql&gt; DROP TABLE temp_person;# or$ mysql&gt; DROP TABLE IF EXISTS temp_person; 创建用户命令： 1$mysql&gt; CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;; 说明： username：你将创建的用户名 host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符% password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 例子： 12345$mysql&gt; CREATE USER &#x27;dog&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;$mysql&gt; CREATE USER &#x27;pig&#x27;@&#x27;192.168.1.101_&#x27; IDENDIFIED BY &#x27;123456&#x27;;$mysql&gt; CREATE USER &#x27;pig&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;$mysql&gt; CREATE USER &#x27;pig&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;&#x27;;$mysql&gt; CREATE USER &#x27;pig&#x27;@&#x27;%&#x27;; 授权命令： 1$mysql&gt; GRANT privileges ON databasename.tablename TO &#x27;username&#x27;@&#x27;host&#x27; 说明: privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL databasename：数据库名 tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.*例子：12$mysql&gt; GRANT SELECT, INSERT ON test.user TO &#x27;pig&#x27;@&#x27;%&#x27;;$mysql&gt; GRANT ALL ON *.* TO &#x27;pig&#x27;@&#x27;%&#x27;; 注意 用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令: 1$mysql&gt; GRANT privileges ON databasename.tablename TO &#x27;username&#x27;@&#x27;host&#x27; WITH GRANT OPTION; 设置与更改用户密码命令： 1$mysql&gt; SET PASSWORD FOR &#x27;username&#x27;@&#x27;host&#x27; = PASSWORD(&#x27;newpassword&#x27;); 如果是当前登陆用户用: 1&gt;$mysql&gt; SET PASSWORD = PASSWORD(&quot;newpassword&quot;);例子： 1$mysql&gt; SET PASSWORD FOR &#x27;pig&#x27;@&#x27;%&#x27; = PASSWORD(&quot;123456&quot;); 撤销用户权限命令： 1$mysql&gt; REVOKE privilege ON databasename.tablename FROM &#x27;username&#x27;@&#x27;host&#x27;; 说明：privilege, databasename, tablename：同授权部分例子： 1$mysql&gt; REVOKE SELECT ON *.* FROM &#x27;pig&#x27;@&#x27;%&#x27;; 注意: 假如你在给用户&#39;pig&#39;@&#39;%&#39;授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO &#39;pig&#39;@&#39;%&#39;，则在使用REVOKE SELECT ON *.* FROM &#39;pig&#39;@&#39;%&#39;; 命令并不能撤销该用户对test数据库中user表的SELECT 操作。 相反，如果授权使用的是GRANT SELECT ON *.* TO &#39;pig&#39;@&#39;%&#39;, 则REVOKE SELECT ON test.user FROM &#39;pig&#39;@&#39;%&#39;; 命令也不能撤销该用户对test数据库中user表的SELECT权限。 具体信息可以用命令SHOW GRANTS FOR &#39;pig&#39;@&#39;%&#39;; 查看。 删除用户 1$mysql&gt; DROP USER &#x27;username&#x27;@&#x27;host&#x27;; 最后能看到这里，那就先要恭喜你了，你已经成功达成建库、建表、建用户到删表、删库、删用户等成就。那还等什么？赶紧跑路吧ε&#x3D;ε&#x3D;ε&#x3D;┏(゜ロ゜;)┛ 附： MySql官网 MySql Tutorial Mysql创建用户并授权命令","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ioliu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MySql","slug":"MySql","permalink":"https://ioliu.cn/tags/MySql/"},{"name":"数据库","slug":"数据库","permalink":"https://ioliu.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"给你的网站加把锁 -- Let's Encrypt 完全体验","slug":"add-a-lock-to-your-website","date":"2017-03-21T10:30:25.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2017/add-a-lock-to-your-website/","permalink":"https://ioliu.cn/2017/add-a-lock-to-your-website/","excerpt":"","text":"今天抽时间将所有的网站SSL证书都更新了成 Let’s Encrypt 了。采用了certbot 这样的自动化工具，配置管理起来非常容易(一本正经的胡说八道)，这里将对整个体验过程做个详细记录。 了解 Let’s Encrypt The project aims to make encrypted connections in the World Wide Web the default case. By getting rid of payment, web server configuration, validation emails and dealing with expired certificates it is meant to significantly lower the complexity of setting up and maintaining TLS encryption.On a Linux web server, execution of only two commands is sufficient to set up HTTPS encryption, acquire and install certificates within 20 to 30 seconds. Let’s Encrypt 是一个2015年末推出的数字证书认证机构，将通过旨在消除当前手动创建和安装证书的复杂过程的自动化流程，为安全网站提供免费的SSL&#x2F;TLS证书。 获取 Let’s EncryptLet’s Encrypt 证书生成不需要手动进行，官方推荐 Certbot 这套自动化工具来实现。4步轻松搞定： 下载安装 certbot (Let’s Encrypt项目的自动化工具) 获得SSL证书 修改Nginx配置文件 续订 1. 安装 Certbot根据 Certbot 官网指南，Debian 8上执行如下命令，安装certbot: 12$ sudo apt-get update$ sudo apt-get install certbot -t jessie-backports 等安装完成，certbot就可以使用了。 2. 获取SSL证书Let’s Encrypt提供了通过各种插件获取SSL证书的各种方法。不同的是Apache的插件，大多数的插件只会帮助你得到，你必须手动配置你的Web服务器使用证书。仅获取证书而不安装证书的插件称为“验证器”，因为它们用于验证服务器是否应颁发证书。下面将使用Webroot的插件来获取SSL证书。 如何使用 Webroot 插件：Webroot 的工作插件放置在一个特殊的文件/.well-known目录文档根目录下，它可以打开（通过Web服务器）内由让我们的加密服务进行验证。 根据配置的不同，你可能需要明确允许访问&#x2F;.well-known目录。 为了确保该目录可供Let’s Encrypt进行验证，让我们快速更改我们的Nginx配置。编辑/etc/nginx/conf.d/example.com.conf文件，并将下面代码添加进去: 123location ~ /.well-known &#123; allow all;&#125; 使用nginx -t测试配置文件是否正确，在正确的情况下，重新让Nginx重新加载配置文件: 1$ sudo systemctl reload nginx 使用certbot命令获取证书：1$ sudo certbot certonly --webroot -w /var/www/example -d example.com -d www.example.com -w /var/www/thing -d thing.is -d m.thing.is -w:指定网站所在目录 -d:指定要生成证书的域名，如果你想多个域名保存在一个证书里(最多四个)(如example.com、www.example.com、thing.is、m.thing.is)，请确保使用适当的webroot路径和域名替换命令中的相对应部分。 接下来，同意加密订阅协议： 如果一切顺利，你应该看到一个类似下面的输出消息： IMPORTANT NOTES: Congratulations! Your certificate and chain have been saved at/etc/letsencrypt/live/example.com/fullchain.pem. Your cert will expireon 2017-06-19. To obtain a new or tweaked version of thiscertificate in the future, simply run certbot again. Tonon-interactively renew all of your certificates, run “certbotrenew” If you like Certbot, please consider supporting our work by: Donating to ISRG &#x2F; Let’s Encrypt: https://letsencrypt.org/donateDonating to EFF: https://eff.org/donate-le 证书文件如果运行顺利，所有服务器所需要的证书就已经生成好了。他们被放在了 /etc/letsencrypt/live/example.com/ 下： 12345$ ls /etc/letsencrypt/live/example.com/cert.pem #server cert only privkey.pem #private key chain.pem #intermediates fullchain.pem #server cert + intermediates 3.修改Nginx配置文件到这里已经成功一大半了，只需要配置 Nginx 支持刚刚生成的证书。最佳实践可以参考Mozilla SSL Configuration Generator。注意去掉HSTS的勾(勾上会强制https，并且很难消除后续影响)。 请根据自己的服务配置修改和添加内容，重点只需要关注6行： 123456789101112server &#123; listen 443 ssl http2; .... ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem; ssl_dhparam /etc/nginx/ssl/dhparam.pem; ssl_trusted_certificate /etc/letsencrypt/live/example.com/root_ca_cert_plus_intermediates; resolver &lt;IP DNS resolver&gt;; ....&#125; dhparam.pem可以通过以下命令生成： 12$ sudo mkdir /etc/nginx/ssl$ sudo openssl dhparam -out /etc/nginx/ssl/dhparam.pem 2048 Nginx 配置完成后重启，用浏览器测试是否一切正常。 4.续订Let&#39;s Encrypt证书有效期只有3个月，所以，需要定时renew。我将使用corntab来执行renew命令: 1$ sudo crontab -e 添加以下行： 130 2 * * 1 /usr/bin/certbot renew &gt;&gt; /var/log/le-renew.log &amp;&amp; /bin/systemctl reload nginx 保存，并退出。这个定时任务将在每个星期一的凌晨两点半执行certbot renew命令，并重启Nginx。最后将日志输出到/var/log/le-renewal.log。 测试你的网站 SSL 安全性Qualys SSL Labs 提供了全面的 SSL 安全性测试，填写你的网站域名，给自己的 HTTPS 配置打个分。这意味着你网站的HTTPS已经启用成功啦，为自己鼓个掌。 (๑•̀ㅂ•́)و✧。 附：还有一种方法，不需要访问你的网站目录，但需要临时停止Nginx服务器(需要用到80端口)： 停止Nginx 域名解析到你的服务器IP 执行命令:certbot certonly --standalone -d example.com -d www.example.com 然后的步骤就和上面一样啦~~~ 以上。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ioliu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"ssl","slug":"ssl","permalink":"https://ioliu.cn/tags/ssl/"},{"name":"cerbot","slug":"cerbot","permalink":"https://ioliu.cn/tags/cerbot/"}]},{"title":"判断变量类型的一些方法","slug":"judgment-variable-type","date":"2016-09-13T14:10:01.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2016/judgment-variable-type/","permalink":"https://ioliu.cn/2016/judgment-variable-type/","excerpt":"","text":"久了不用，就会发现，以前会的东西都会忘记掉(或者是完全想不起来了)，不知道你们有没有遇到过这个情况 - -! 这里只是对判断变量类型方法的一些记录，方便以后能够随时查看。 typeof要判断变量类型，首先想到的就是typeof，但用了才知道，其结果完全不是理想中的: 123456typeof &#123;&#125;; //&quot;object&quot;typeof []; //&quot;object&quot;typeof &quot;&quot;; //&quot;string&quot;typeof 0; //&quot;number&quot;typeof function()&#123;&#125;;//&quot;function&quot;typeof true;//&quot;boolean&quot; 由上面代码可以看出，数组也是对象，所以typeof不是我们理想中的解决方案。 当然，有的童鞋可能会说，由于length是Array特有的属性(非绝对),那是不是可以用length+typeof来判断。 当然，这是可以的： 12345var arr = [1,2];if(typeof arr === &#x27;object&#x27;)&#123; console.log(typeof arr.length === &quot;number&quot; ? &quot;array&quot; : &quot;object&quot;);//这里输出 &quot;array&quot;&#125;//...其他的就不一一罗列了 不过这个方法不通用，如果&#123;key:value&#125;对象中有 length 字段呢，如： 123456//这种情况对于上面的代码就不适用了var obj = &#123; name:&quot;square&quot;, length:50, width:50&#125;; instanceof第二种解决方案就是使用instanceof，不过使用instanceof会出现[] instanceof Object === true的情况。这样就需要优先判断Array： 1234567891011121314151617var a = [1,2,3];var b = &#123;name:&#x27;zhangsan&#x27;,sex:123&#125;;var fn = function()&#123;&#125;;var detectType = function(o)&#123; if(o instanceof Array)&#123; return &#x27;Array&#x27; &#125;else if( o instanceof Object )&#123; return &#x27;Object&#x27;; &#125;else&#123; return &#x27;param is no object type&#x27;; &#125;&#125;console.log( detectType(a) ); // Arrayconsole.log( detectType(b) ); // Objectconsole.log( detectType(1) ); // param is no object typeconsole.log( detectType(true) ); // param is no object typeconsole.log( detectType(&#x27;a&#x27;) ); // param is no object type Object.prototype.toString.call还有一种最靠谱的办法就是Object.prototype.toString.call: 12345678910Object.prototype.toString.call([]) //&quot;[object Array]&quot;Object.prototype.toString.call(Object) //&quot;[object Function]&quot;Object.prototype.toString.call(function x()&#123;&#125;) //&quot;[object Function]&quot;Object.prototype.toString.call(&quot;&quot;) //&quot;[object String]&quot;Object.prototype.toString.call(&#123;&#125;) //&quot;[object Object]&quot;Object.prototype.toString.call(null) //&quot;[object Null]&quot;Object.prototype.toString.call(undefined) //&quot;[object Undefined]&quot;Object.prototype.toString.call(/test/) //&quot;[object RegExp]&quot;Object.prototype.toString.call(new Date()) //&quot;[object Date]&quot; 参考文档 Object.prototype.toString()","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ioliu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ioliu.cn/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"https://ioliu.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"变量类型","slug":"变量类型","permalink":"https://ioliu.cn/tags/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"}]},{"title":"CSS 内容和特殊字符","slug":"css-content-and-special-characters","date":"2016-09-06T06:10:01.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2016/css-content-and-special-characters/","permalink":"https://ioliu.cn/2016/css-content-and-special-characters/","excerpt":"","text":"当我写这个主题theme的时候，我想在我的列表元素(list elements)上用CSS内容(CSS content)属性添加一些**向右双角引号(right-pointing double-angle quotation marks)(&lt;&lt;)**。 所以，我在里面添加了&amp;raquo;，然而，它并不工作！ 我花了一点时间去了解到，你不能使用常规的 HTML 实体内容。相反，你必须使用 Unicode 十六进制格式，它看起来像这样：\\bb。 这是一些你可以轻而易举找到的东西，只因为它出现在了众多课程和参考书里。 将HTML实体转换成Unicode十六进制代码这里有很多的HTML实体对应表，但是没有更多的 Unicode十六进制表，所以很方便的知道二者之间的转换。你需要知道所有的HTML十进制单位(它们看起来像这样&amp;#123;，而不是像这样&amp;quot;)。那数字，你猜到了吧，就是十进制格式。我们需要将其转换成Unicode十六进制(我知道，你震惊了！)。 如果你不是一个程序员或者数学天才，可能你不熟悉到底该怎么做(具体请Google)。OK，其实这并不难，但有一个更快捷的方式: 打开类似于经典的Windows计算器，切换到“程序员”视图(View &gt; Programmer)。点击Dec(十进制)单选按钮，输入你的数字然后点击Hex(十六进制)按钮，你就会得到你的十六进制数字。 然后把刚刚得到的数字放到\\之后，你就得到了你自己的Unicode十六进制字符。 更容易的方法 - HTML实体(HTML Entity)和 Unicode 十六进制 对应表这个方法不需要你手动的将十进制转成十六进制，这个图表能够给你一些常见的(或者不是那么常见的)符号的参考：","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"https://ioliu.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://ioliu.cn/tags/CSS/"},{"name":"译文","slug":"译文","permalink":"https://ioliu.cn/tags/%E8%AF%91%E6%96%87/"}],"author":"@Christian Snodgrass"},{"title":"JavaScript 最佳实践: 提升你代码质量的一些提示&技巧","slug":"javascript-best-practices-tips-and-tricks-to-level-up-your-code","date":"2016-09-02T06:10:01.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2016/javascript-best-practices-tips-and-tricks-to-level-up-your-code/","permalink":"https://ioliu.cn/2016/javascript-best-practices-tips-and-tricks-to-level-up-your-code/","excerpt":"","text":"每天学习新事物是成为一个伟大的人的一部分。而对开发者而言，持续不断学习新的东西是我们工作中的一部分，无论这些东西是否是你主动想学的。 在本教程中，我会指出一些重要的 JavaScript 最佳实践，因此你不必觉得学习它是条艰难的路。准备提升你的代码吧！ 避免全局污染(Avoid polluting the global scope)声明变量(Declaring variables)是很有趣的。有时候，你可能声明了全局变量，即使你不想声明它。在如今的浏览器中，全局变量存储在window对象中。因此，有很多有趣的东西发生在那里，你可能会重写默认值。让我们假设你有一个HTML文件，其中包含一个&lt;script&gt;标签(或者在加载的 JavaScript 文件中包含): 12var foo = 42;console.log(foo); 这很显然会在控制台输出42。但是，因为这段代码没有在函数中执行，上下文将是一个全局的。因此，变量是附加到window对象的。这意味着window.foo的值也是42。 这是危险的，因为你可以重写已经存在的全局变量: 12345function print()&#123; //do something...&#125;print(); 因为我们重写了原生的打印弹窗(native print popup)，所以当我们执行window.print() (或者只执行print())的时候不会打开打印弹窗(print popup)。 这个问题很好解决，我们需要一个立即调用(called immediately) 的包装函数(wrapping function) (译者注:作者这里可能是要表达一个闭包函数closure function或者是匿名函数anonymous function)，像下面的代码: 12345678910// Declare an anonymous function// 声明一个匿名函数(function () &#123; var foo = 42; console.log(window.foo); // → undefined console.log(foo); // → 42&#125;)();//^ and call it immediately 另外，你应该选择发送window和其他的全局变量(如:document)作为函数的参数(这可能会提高性能): 12345(function (global, doc) &#123; global.setTimeout(function () &#123; doc.body.innerHTML = &quot;Hello!&quot;; &#125;, 1000);&#125;)(window, document); 因此，使用包装函数来防止创建不必要的全局变量。注意，这不是说我在接下来的代码片段使用包装函数，我们应该把关注点放在代码本身。 💡小提示: browserify是另外一种防止创建不必要的全局变量的方式。它和 Node.js 采用的是同样的方式，使用的require function。 学习更多关于浏览器开发者工具请点击 Web 开发指南 顺便说一句，Node.js 会在函数里自动打包你的文件，它们看起来像这样： 12(function (exports, require, module, __filename, __dirname) &#123;// ... 因此，如果这让你认为require函数是全局的那就错了。它只不过是一个函数的参数罢了。 你知道吗？由于window对象本身就是一个包含全局变量的全局变量，因此它的引用是自身: 12window.window.window// =&gt; Window &#123;...&#125; 那是因为window对象是一个环路对象(circular object)，下面演示怎么创建一个这样的对象： 12345678910// Create an Objectvar foo = &#123;&#125;;// Point a key value to the object itself// 设置一个key，值为它本身foo.bar = foo;// The `foo` object just became a circular one:foo.bar.bar.bar// → foo 或者，去展现你对JavaScript 的爱，你可以做得更好：Yes，你可以无限的扩展这个对象(大概直到你的浏览器崩溃). 使用严格模式(use strict)严格的使用use strict！这只不过是(译者注:这里原作者可能是想表达不仅仅是)在你的代码脚本中添加字符串而已。举个栗子： 12345678// This is bad, since you do create a global without having anyone to tell you(function () &#123; a = 42; console.log(a); // → 42&#125;)();console.log(a);// → 42 使用use strict，你可以得到更多的确切的错误： 12345(function () &#123; &quot;use strict&quot;; a = 42; // Error: Uncaught ReferenceError: a is not defined&#125;)(); 你可能会奇怪，为什么不能将use strict 写在函数体外。当然，这是可以的，但它将会应用为全局的范围。这仍然是不错的，但如果你的代码中含有来自其他库的代码，这也会受其影响，或者你把所有的东西都绑定在一个文件里。 严格相等(Strict equal)这是短的。如果你使用==对比a和b(像在其他编程语言)，在 JavaScript 中，你可能这种非常奇怪的运行方式：如果你有一个字符串和一个数字，他们是相等的(==): 12&quot;42&quot; == 42// → true 由于显而易见的原因(如 验证(validations))，最好使用严格相等(===)： 12&quot;42&quot; === 42// → false 使用断言(&amp;&amp;&#x2F;||)根据你的需要，你可以使用逻辑运算符是你的代码更简短。默认值: 123456789101112131415&quot;&quot; || &quot;foo&quot;// → &quot;foo&quot;undefined || 42// → 42// Note that if you want to handle 0 there, you need// to check if a number was provided:var a = 0;a || 42// → 42// This is a ternary operator—works like an inline if-else statementvar b = typeof a === &quot;number&quot; ? a : 42;// → 0 检查是否是一个真正的if表达式，你可以简单的这么做： 123456expr &amp;&amp; doSomething();// Instead of:if (expr) &#123; doSomething();&#125; 你可能会不赞同我这里的写法，但是这是比较理想的。如果你不想用这种方式丑化你的代码，但那些 JavaScript 压缩工具实际上会这么做。 如果你问我，尽管这些代码比较短，但它仍然是人类可读的。 类型转换有几种方式来转换这些东西，这取决于你想怎么做。最常见的方式是： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// From anything to a numbervar foo = &quot;42&quot;;var myNumber = +foo; // shortcut for Number(foo)// → 42// Tip: you can convert it directly into a negative numbervar negativeFoo = -foo; // or -Number(foo)// → -42// From object to array// Tip: `arguments` is an object and in general you want to use it as arrayvar args = &#123; 0: &quot;foo&quot;, 1: &quot;bar&quot;, length: 2 &#125;;Array.prototype.slice.call(args)// → [ &#x27;foo&#x27;, &#x27;bar&#x27; ]// Anything to boolean/// Non non p is a boolean pvar t = 1;var f = 0;!!t// → true!!f// → false/// And non-p is a boolean non-p!t// → false!f// → true// Anything to stringvar foo = 42;&quot;&quot; + foo // shortcut for String(foo)// → &quot;42&quot;foo = &#123; hello: &quot;world&quot; &#125;;JSON.stringify(foo);// → &#x27;&#123; &quot;hello&quot;:&quot;world&quot; &#125;&#x27;JSON.stringify(foo, null, 4); // beautify the things// →// &#x27;&#123;// &quot;hello&quot;: &quot;world&quot;// &#125;&#x27;// Note you cannot JSON.stringify circular structuresJSON.stringify(window);// ⚠ TypeError: JSON.stringify cannot serialize cyclic structures. 代码样式&#x2F;样式指南在新项目中，遵循整个文件相同的代码风格。对于现有的，采用已经存在的代码风格，除非你只是决定改变它(提示：同你的合作者商讨)。即使你创建并记录你的代码风格，请始终遵循它。 这里是不同的现有的代码样式： Google JavaScript Style Guide airbnb&#x2F;javascript … there are others too my style guide 附加提示其他重要的 JavaScript 最佳实践，你应该记住的是使用工具帮助你格式化你的代码。这是其中的一些： js-beautify: Beautifies your code UglifyJS(2): Uglifies&#x2F;minimifies your code jshint: Detects errors&#x2F;potential problems in your JavaScript code jscs: A configurable style guide checker 最后一件事：Debug your Code Happy programming! 致谢：@屠夫 、@QistChan、@nApolin、@Ant","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ioliu.cn/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"https://ioliu.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"译文","slug":"译文","permalink":"https://ioliu.cn/tags/%E8%AF%91%E6%96%87/"},{"name":"技巧","slug":"技巧","permalink":"https://ioliu.cn/tags/%E6%8A%80%E5%B7%A7/"}],"author":"@johnnyb"},{"title":"MarkDown 不完全指南","slug":"MarkDown-incomplete-Guide","date":"2016-05-18T06:21:08.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2016/MarkDown-incomplete-Guide/","permalink":"https://ioliu.cn/2016/MarkDown-incomplete-Guide/","excerpt":"","text":"MarkdownA markdown example shows how to write a markdown file. This document integrates core syntax and extensions (GMF). Block ElementsParagraphs and Line BreaksParagraphsHTML Tag: &lt;p&gt; One or more blank lines. (A blank line is a line containing nothing but spaces or tabs is considered blank.) Code: 1234This will be inline.This is second paragraph. Preview: This will beinline. This is second paragraph. Line BreaksHTML Tag: &lt;br /&gt; End a line with two or more spaces. Code: 12This will be not inline. Preview: This will be notinline. HeadersMarkdown supports two styles of headers, Setext and atx. SetextHTML Tags: &lt;h1&gt;, &lt;h2&gt; “Underlined” using equal signs (&#x3D;) as &lt;h1&gt; and dashes (-) as &lt;h2&gt; in any number. Code:1234This is an H1=============This is an H2-------------Preview:***This is an H1This is an H2 atxHTML Tags: &lt;h1&gt;, &lt;h2&gt;, &lt;h3&gt;, &lt;h4&gt;, &lt;h5&gt;, &lt;h6&gt; Uses 1-6 hash characters (#) at the start of the line, corresponding to &lt;h1&gt; - &lt;h6&gt;. Code: 123# This is an H1## This is an H2###### This is an H6 Preview: This is an H1This is an H2This is an H6 Optionally, you may “close” atx-style headers. The closing hashes don’t need to match the number of hashes used to open the header. Code: 123# This is an H1 ### This is an H2 ##### This is an H3 ###### Preview: This is an H1This is an H2This is an H3 BlockquotesHTML Tag: &lt;blockquote&gt; Markdown uses email-style &gt; characters for blockquoting. It looks best if you hard wrap the text and put a &gt; before every line. Code: 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. Preview: This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. Markdown allows you to be lazy and only put the &gt; before the first line of a hard-wrapped paragraph. Code: 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. Preview: This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. Blockquotes can be nested (i.e. a blockquote-in-a-blockquote) by adding additional levels of &gt;. Code: 12345&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. Preview: This is the first level of quoting. This is nested blockquote. Back to the first level. Blockquotes can contain other Markdown elements, including headers, lists, and code blocks. Code: 12345678&gt; ## This is a header.&gt; &gt; 1. This is the first list item.&gt; 2. This is the second list item.&gt; &gt; Here&#x27;s some example code:&gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); Preview: This is a header. This is the first list item. This is the second list item. Here’s some example code: return shell_exec(&quot;echo $input | $markdown_script&quot;); ListsMarkdown supports ordered (numbered) and unordered (bulleted) lists. UnorderedHTML Tag: &lt;ul&gt; Unordered lists use asterisks (*), pluses (+), and hyphens (-). Code: 123* Red* Green* Blue Preview: Red Green Blue is equivalent to: Code: 123+ Red+ Green+ Blue and: Code: 123- Red- Green- Blue OrderedHTML Tag: &lt;ol&gt; Ordered lists use numbers followed by periods: Code: 1231. Bird2. McHale3. Parish Preview: Bird McHale Parish It’s possible to trigger an ordered list by accident, by writing something like this: Code: 11986. What a great season. Preview: What a great season. You can backslash-escape (\\) the period: Code: 11986\\. What a great season. Preview: 1986. What a great season. IndentedBlockquoteTo put a blockquote within a list item, the blockquote’s &gt; delimiters need to be indented: Code: 1234* A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. Preview: A list item with a blockquote: This is a blockquoteinside a list item. Code BlockTo put a code block within a list item, the code block needs to be indented twice — 8 spaces or two tabs: Code: 123* A list item with a code block: &lt;code goes here&gt; Preview: A list item with a code block: &lt;code goes here&gt; Nested ListCode: 12345* A * A1 * A2* B* C Preview: A A1 A2 B C Code BlocksHTML Tag: &lt;pre&gt; Indent every line of the block by at least 4 spaces or 1 tab. Code: 123This is a normal paragraph: This is a code block. Preview: This is a normal paragraph: This is a code block. A code block continues until it reaches a line that is not indented (or the end of the article). Within a code block, ampersands (&amp;) and angle brackets (&lt; and &gt;) are automatically converted into HTML entities. Code: 123&lt;div class=&quot;thanclass&quot;&gt; &amp;copy; 2004 Foo Corporation&lt;/div&gt; Preview: &copy; 2004 Foo Corporation *** Following sections Fenced Code Blocks and Syntax Highlighting are extensions, you can use the other way to write the code block. #### Fenced Code Blocks Just wrap your code in \\`\\`\\` \\`\\`\\` (as shown below) and you won't need to indent it by four spaces. Code: Here’s an example:&#96;&#96;&#96;function test() { console.log(“notice the blank line before this function?”);}&#96;&#96;&#96; Preview: Here’s an example: 123function test() &#123; console.log(&quot;notice the blank line before this function?&quot;);&#125; Syntax HighlightingIn your fenced block, add an optional language identifier and we’ll run it through syntax highlighting (Support Languages). Code: &#96;&#96;&#96;rubyrequire ‘redcarpet’markdown &#x3D; Redcarpet.new(“Hello World!”)puts markdown.to_html&#96;&#96;&#96; Preview: 123require &#x27;redcarpet&#x27;markdown = Redcarpet.new(&quot;Hello World!&quot;)puts markdown.to_html Horizontal RulesHTML Tag: &lt;hr /&gt;Places three or more hyphens (-), asterisks (*), or underscores (_) on a line by themselves. You may use spaces between the hyphens or asterisks. Code: 123456* * *********- - ----------------------------------------___ TableHTML Tag: &lt;table&gt; It’s an extension. Separates column by pipe (|) and header by dashes (-), and uses colon (:) for alignment. The outer pipes (|) and alignment are optional. There are 3 delimiters each cell at least for separating header. Code: 12345678910111213| Left | Center | Right ||:-----|:------:|------:||aaa |bbb |ccc ||ddd |eee |fff | A | B ---|---123|456A |B --|--12|45 Preview: Left Center Right aaa bbb ccc ddd eee fff A B 123 456 A B 12 45 Span ElementsLinksHTML Tag: &lt;a&gt; Markdown supports two style of links: inline and reference. InlineInline link format like this: [Link Text](URL &quot;Title&quot;) Title is optional. Code: 123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. Preview: This is an example inline link. This link has no title attribute. If you’re referring to a local resource on the same server, you can use relative paths: Code: 1See my [Tags](/tags/) page for details. Preview: See my Tags page for details. ReferenceYou could predefine link references. Format like this: [id]: URL &quot;Title&quot; Title is also optional. And the you refer the link, format like this: [Link Text][id] Code: 12[id]: http://example.com/ &quot;Optional Title Here&quot;This is [an example][id] reference-style link. Preview: This is 点我跳转到百度 reference-style link. That is: Square brackets containing the link identifier (not case sensitive, optionally indented from the left margin using up to three spaces); followed by a colon; followed by one or more spaces (or tabs); followed by the URL for the link; The link URL may, optionally, be surrounded by angle brackets. optionally followed by a title attribute for the link, enclosed in double or single quotes, or enclosed in parentheses. The following three link definitions are equivalent: Code: 1234[foo]: http://example.com/ &quot;Optional Title Here&quot;[foo]: http://example.com/ &#x27;Optional Title Here&#x27;[foo]: http://example.com/ (Optional Title Here)[foo]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; Uses an empty set of square brackets, the link text itself is used as the name. Code: 12[Google]: http://google.com/[Google][] Preview: Google EmphasisHTML Tags: &lt;em&gt;, &lt;strong&gt; Markdown treats asterisks (*) and underscores (_) as indicators of emphasis. One delimiter will be &lt;em&gt;; *double delimiters will be &lt;strong&gt;. Code: 1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ Preview: single asterisks single underscores double asterisks double underscores But if you surround an * or _ with spaces, it’ll be treated as a literal asterisk or underscore. You can backslash escape it: Code: 1*this text is surrounded by literal asterisks* Preview: *this text is surrounded by literal asterisks* CodeHTML Tag: &lt;code&gt; Wraps it with backtick quotes (&#96;). Code: 1Use the `printf()` function. Preview: Use the printf() function. To include a literal backtick character within a code span, you can use multiple backticks as the opening and closing delimiters: Code: 1``There is a literal backtick (`) here.`` Preview: There is a literal backtick (`) here. The backtick delimiters surrounding a code span may include spaces — one after the opening, one before the closing. This allows you to place literal backtick characters at the beginning or end of a code span: Code: 123A single backtick in a code span: `` ` ``A backtick-delimited string in a code span: `` `foo` `` Preview: A single backtick in a code span: ` A backtick-delimited string in a code span: `foo` ImagesHTML Tag: &lt;img /&gt; Markdown uses an image syntax that is intended to resemble the syntax for links, allowing for two styles: inline and reference. InlineInline image syntax looks like this: ![Alt text](URL &quot;Title&quot;) Title is optional. Code: 123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;) Preview: That is: An exclamation mark: !; followed by a set of square brackets, containing the alt attribute text for the image; followed by a set of parentheses, containing the URL or path to the image, and an optional title attribute enclosed in double or single quotes. ReferenceReference-style image syntax looks like this: ![Alt text][id] Code: 12[img id]: url/to/image &quot;Optional title attribute&quot;![Alt text][img id] Preview: StrikethroughHTML Tag: &lt;del&gt; It’s an extension. GFM adds syntax to strikethrough text. Code: 1~~Mistaken text.~~ Preview: Mistaken text. MiscellaneousAutomatic LinksMarkdown supports a shortcut style for creating “automatic” links for URLs and email addresses: simply surround the URL or email address with angle brackets. Code: 123&lt;http://example.com/&gt;&lt;address@example.com&gt; Preview: http://example.com/ &#97;&#100;&#x64;&#x72;&#101;&#x73;&#115;&#64;&#101;&#x78;&#97;&#x6d;&#x70;&#108;&#x65;&#x2e;&#x63;&#111;&#109; GFM will autolink standard URLs. Code: 1https://github.com/xcss Preview: https://github.com/xcss Backslash EscapesMarkdown allows you to use backslash escapes to generate literal characters which would otherwise have special meaning in Markdown’s formatting syntax. Code: 1\\*literal asterisks\\* Preview: *literal asterisks* Markdown provides backslash escapes for the following characters: Code: 123456789101112\\ backslash` backtick* asterisk_ underscore&#123;&#125; curly braces[] square brackets() parentheses# hash mark+ plus sign- minus sign (hyphen). dot! exclamation mark Inline HTMLFor any markup that is not covered by Markdown’s syntax, you simply use HTML itself. There’s no need to preface it or delimit it to indicate that you’re switching from Markdown to HTML; you just use the tags. Code: 123456789This is a regular paragraph.&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;This is another regular paragraph. Preview: This is a regular paragraph. Foo This is another regular paragraph. *** Note that Markdown formatting syntax is **not processed within block-level HTML tags**. Unlike block-level HTML tags, Markdown syntax is processed within span-level tags. Code: 12345&lt;span&gt;**Work**&lt;/span&gt;&lt;div&gt; **No Work**&lt;/div&gt; Preview: Work **No Work** *** 参考文档: http://www.markdown.cn/","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ioliu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://ioliu.cn/tags/MarkDown/"},{"name":"Guide","slug":"Guide","permalink":"https://ioliu.cn/tags/Guide/"}]},{"title":"响应式设计 (Responsive Design) 中常用的媒体查询","slug":"commonly-used-media-queries","date":"2016-05-11T11:21:08.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2016/commonly-used-media-queries/","permalink":"https://ioliu.cn/2016/commonly-used-media-queries/","excerpt":"","text":"现在Web朝着响应式的趋势发展，媒体查询在创建响应式网站中起到了主要作用。 没有媒体查询几乎不能实现响应式设计，利用媒体查询，我们可以针对特定的设备，如显示器、智能手机和平板，写CSS。 媒体查询是响应式设计的核心 在这篇文章中我将分享一些到目前为止我收集到的常用媒体查询。在一些示例中，我可能是错误的，但是不用担心，因为我针对这个开通了评论功能。我把它们分为显示器媒体查询、智能手机媒体查询和平板媒体查询 显示器媒体查询显示器媒体查询是以屏幕大小为基础划分的 640px123@media screen and (max-width: 640px)&#123; /*some rules*/&#125; 800px123@media screen and (max-width: 800px)&#123; /*some rules*/&#125; 1024px123@media screen and (max-width: 1024px)&#123; /*some rules*/&#125; 智能手机媒体查询适用于大部分主流智能手机 iPhone(2G-4S)12345678/*Landscape Mode*/@media screen and (max-device-width: 480px) and (orientation:landscape)&#123; /*some rules*/&#125;/* Portrait Mode */@media screen and (max-device-width: 320px) and (orientation:portrait)&#123; /*some rules*/&#125; iPhone 41234@media only screen and (-webkit-min-device-pixel-ratio : 1.5),only screen and (min-device-pixel-ratio : 1.5)&#123; /*some rules*/&#125; iPhone 512345@media only screenand (min-device-width : 320px)and (max-device-width : 568px)&#123; /*some rules*/&#125; iPhone 612345678910111213141516171819202122232425262728293031@media only screen and (min-device-width: 375px) and (max-device-width: 667px)and (orientation : portrait) &#123; /*iPhone 6 Portrait*/&#125;@media only screen and (min-device-width: 375px) and (max-device-width: 667px) and (orientation : landscape) &#123; /*iPhone 6 landscape*/&#125;@media only screen and (min-device-width: 414px) and (max-device-width: 736px)and (orientation : portrait) &#123; /*iPhone 6+ Portrait*/&#125;@media only screen and (min-device-width: 414px) and (max-device-width: 736px)and (orientation : landscape) &#123; /*iPhone 6+ landscape*/&#125;@media only screen and (max-device-width: 640px), only screen and (max-device-width: 667px),only screen and (max-width: 480px)&#123; /*iPhone 6 and iPhone 6+ portrait and landscape*/&#125;@media only screen and (max-device-width: 640px),only screen and (max-device-width: 667px),only screen and (max-width: 480px) and (orientation : portrait)&#123; /*iPhone 6 and iPhone 6+ portrait*/&#125;@media only screen and (max-device-width: 640px),only screen and (max-device-width: 667px),only screen and (max-width: 480px) and (orientation : landscape)&#123; /*iPhone 6 and iPhone 6+ landscape*/&#125; HTC Evo，BlackBerry Torch，HTC Thunderbolt，HD2123@media screen and (max-device-width: 480px)&#123; /*some rules*/&#125; 平板媒体查询iPad &#x2F; iPad 2 &#x2F; iPad 312345678/* Landscape Mode */@media (max-device-width: 1024px) and (orientation: landscape)&#123; /*some rules*/&#125;/* Portrait Mode */@media (max-device-width: 768px) and (orientation: portrait)&#123; /*some rules*/&#125; iPad Mini123456@media only screenand (min-device-width : 768px)and (max-device-width : 1024px)and (-webkit-min-device-pixel-ratio: 1)&#123; /*some rules*/&#125; Samsung Galaxy Tab 10.1 &#x2F; Motorola Xoom &#x2F; Lenovo Thinkpad Tablet &#x2F; Sony Tablet S12345678/* Landscape Mode */@media (max-device-width: 1280px) and (orientation: landscape)&#123; /*some rules*/&#125;/* Portrait Mode */@media (max-device-width: 800px) and (orientation: portrait)&#123; /*some rules*/&#125; HTC Flyer &#x2F; BlackBerry PlayBook12345678/* Landscape Mode */@media (max-device-width: 1024px) and (orientation: landscape)&#123; /*some rules*/&#125;/* Portrait Mode */@media (max-device-width: 600px) and (orientation: portrait)&#123; /*some rules*/&#125; HP TouchPad12345678/* Landscape Mode */@media (max-device-width: 1024px) and (orientation: landscape)&#123; /*some rules*/&#125;/* Portrait Mode */@media (max-device-width: 768px) and (orientation: portrait)&#123; /*some rules*/&#125; T-Mobile G-Slate12345678/* Landscape Mode */@media (max-device-width: 1280px) and (orientation: landscape)&#123; /*some rules*/&#125;/* Portrait Mode */@media (max-device-width: 768px) and (orientation: portrait)&#123; /*some rules*/&#125; ViewSonic ViewPad 1012345678/* Landscape Mode */@media (max-device-width: 1024px) and (orientation: landscape)&#123; /*some rules*/&#125;/* Portrait Mode */@media (max-device-width: 600px) and (orientation: portrait)&#123; /*some rules*/&#125; Dell Streak 712345678/* Landscape Mode */@media (max-device-width: 800px) and (orientation: landscape)&#123; /*some rules*/&#125;/* Portrait Mode */@media (max-device-width: 400px) and (orientation: portrait)&#123; /*some rules*/&#125; ASUS Eee Pad Transformer12345678/* Landscape Mode */@media (max-device-width: 1080px) and (orientation: landscape)&#123; /*some rules*/&#125;/* Portrait Mode */@media (max-device-width: 800px) and (orientation: portrait)&#123; /*some rules*/&#125; 其他参考文档 七个高度有效的媒体查询技巧 iPads和iPhones的Media Queries media-queries-for-standard-devices 本文转载自淡忘~浅思,略有删改,侵权即删.原文链接: Some Media Queries for Responsive Design译文链接: 【译】Responsive Design常用的媒体查询","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ioliu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Media Query","slug":"Media-Query","permalink":"https://ioliu.cn/tags/Media-Query/"},{"name":"响应式","slug":"响应式","permalink":"https://ioliu.cn/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"媒体查询","slug":"媒体查询","permalink":"https://ioliu.cn/tags/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"}]},{"title":"生成 SSH Key 免密码提交 GitHub","slug":"generating-ssh-key","date":"2015-12-13T02:19:18.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2015/generating-ssh-key/","permalink":"https://ioliu.cn/2015/generating-ssh-key/","excerpt":"","text":"之前上传文件到 GitHub 的时候，一直都是用的账号密码登录，每次提交都弹个窗体出来，感觉烦死了。。。今天有空，就来捣鼓下 SSH Key。 Step1. 检查是否已经存在 SSH Key运行 Git Bush 客户端，执行以下代码： 12$ ls -al ~/.ssh # 如果存在，将会列出.ssh 目录下的所有文件 12# 如果不存在则会给出如下提示ls: cannot open directory /Users/you/.ssh: Permission denied 检查列出来的目录，看看是否已经有了一个 SSH Key。默认情况下，key 的文件名是下列之一： &gt; id_dsa.pub &gt; id_ecdsa.pub &gt; id_ed25519.pub &gt; id_rsa.pub 如果已经存在(如 id_rsa 和 id_rsa.pub)而且你想使用已经存在的密钥对直接连接 GitHub ，那么可以跳过 Step2，直接进入 Step3 Step2. 生成 SSH Key复制下面的代码(记得请将email修改成自己的email地址)： 12$ ssh-keygen -t rsa -b 4096 -C &quot;your_name@example.com&quot; Generating public/private rsa key pair. 这里 GitHub 的建议是保持默认，所以只需要按 Enter 继续： 1Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press Enter] 如果存在，将会提示是否覆盖： 12/Users/you/.ssh/id_rsa already exists.Overwrite (y/n)? 继续后会提示输入密码： 12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 然后你就会得到你的 SSH Key 的指纹，看起来像下面的代码： 1234Your identification has been saved in /Users/you/.ssh/id_rsa.Your public key has been saved in /Users/you/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com Step3. 添加 SSH Key 到 GitHub先拷贝 id_rsa.pub 文件的内容，可以用编辑器打开然后复制，也可以用 git 命令复制： 1$ clip &lt; ~/.ssh/id_rsa.pub 进入 GitHub 账户设置，点击左边 SSH Key ，点击 Add SSH key ，粘贴刚刚复制的内容，然后保存。输入 GitHub 账户的密码就能看到刚刚添加的 SSH Key 了。 Step4. 测试是否添加成功在 Git Bush 中输入下面的代码，然后回车 12$ ssh -T git@GitHub.com# Attempts to ssh to GitHub 会得到如下的指纹提示：键入yes 123The authenticity of host &#x27;GitHub.com (207.97.227.239)&#x27; can&#x27;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 如果出现下面的提示，恭喜你，验证成功。 1Hi username! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 如果你看到的是 access denied(拒绝访问) ，可以点击这里 ，查看解决办法。 然后将https替换成ssh重新下载下代码，就OK了~~~ Good Luck ** 参考文档 ** Generating SSH keys","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ioliu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://ioliu.cn/tags/GitHub/"},{"name":"SSH Key","slug":"SSH-Key","permalink":"https://ioliu.cn/tags/SSH-Key/"},{"name":"免密码","slug":"免密码","permalink":"https://ioliu.cn/tags/%E5%85%8D%E5%AF%86%E7%A0%81/"}]},{"title":"前端 JavaScript 规范","slug":"the-front-end-javascript-specification","date":"2015-05-12T04:53:34.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2015/the-front-end-javascript-specification/","permalink":"https://ioliu.cn/2015/the-front-end-javascript-specification/","excerpt":"","text":"类型原始值:相当于传值(JavaScript对象都提供了字面量)，使用字面量创建对象。 string number boolean null undefined 1234var foo = 1, bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 复杂类型:相当于传引用 object array function 1234var foo = [1, 2], bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 对象 使用字面值创建对象 12345// badvar item = new Object();// goodvar item = &#123;&#125;; 不要使用保留字 reserved words 作为键 12345678910111213// badvar superman = &#123; class: &#x27;superhero&#x27;, default: &#123; clark: &#x27;kent&#x27; &#125;, private: true&#125;;// goodvar superman = &#123; klass: &#x27;superhero&#x27;, defaults: &#123; clark: &#x27;kent&#x27; &#125;, hidden: true&#125;; 数组 使用字面值创建数组 12345// badvar items = new Array();// goodvar items = []; 如果你不知道数组的长度，使用push 1234567var someStack = [];// badsomeStack[someStack.length] = &#x27;abracadabra&#x27;;// goodsomeStack.push(&#x27;abracadabra&#x27;); 当你需要拷贝数组时使用slice . jsPerf 1234567891011var len = items.length, itemsCopy = [], i;// badfor (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// gooditemsCopy = items.slice(); 使用slice将类数组的对象转成数组.1234function trigger() &#123; var args = [].slice.apply(arguments); ...&#125; 字符串 对字符串使用单引号 &#39;&#39;(因为大多时候我们的字符串。特别html会出现&quot;)1234567891011// badvar name = &quot;Bob Parr&quot;;// goodvar name = &#x27;Bob Parr&#x27;;// badvar fullName = &quot;Bob &quot; + this.lastName;// goodvar fullName = &#x27;Bob &#x27; + this.lastName; 超过80(也有规定140的，项目具体可制定)个字符的字符串应该使用字符串连接换行!!!: 如果过度使用，长字符串连接可能会对性能有影响. jsPerf &amp; Discussion 123456789101112131415161718// badvar errorMessage = &#x27;This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.&#x27;;// badvar errorMessage = &#x27;This is a super long error that \\was thrown because of Batman. \\When you stop to think about \\how Batman had anything to do \\with this, you would get nowhere \\fast.&#x27;;// goodvar errorMessage = &#x27;This is a super long error that &#x27; + &#x27;was thrown because of Batman.&#x27; + &#x27;When you stop to think about &#x27; + &#x27;how Batman had anything to do &#x27; + &#x27;with this, you would get nowhere &#x27; + &#x27;fast.&#x27;; 编程时使用join而不是字符串连接来构建字符串，特别是IE: jsPerf.12345678910111213141516171819202122232425262728293031323334var items, messages, length, i;messages = [&#123; state: &#x27;success&#x27;, message: &#x27;This one worked.&#x27;&#125;,&#123; state: &#x27;success&#x27;, message: &#x27;This one worked as well.&#x27;&#125;,&#123; state: &#x27;error&#x27;, message: &#x27;This one did not work.&#x27;&#125;];length = messages.length;// badfunction inbox(messages) &#123; items = &#x27;&lt;ul&gt;&#x27;; for (i = 0; i &lt; length; i++) &#123; items += &#x27;&lt;li&gt;&#x27; + messages[i].message + &#x27;&lt;/li&gt;&#x27;; &#125; return items + &#x27;&lt;/ul&gt;&#x27;;&#125;// goodfunction inbox(messages) &#123; items = []; for (i = 0; i &lt; length; i++) &#123; items[i] = messages[i].message; &#125; return &#x27;&lt;ul&gt;&lt;li&gt;&#x27; + items.join(&#x27;&lt;/li&gt;&lt;li&gt;&#x27;) + &#x27;&lt;/li&gt;&lt;/ul&gt;&#x27;;&#125; 函数 函数表达式:1234567891011121314// 匿名函数表达式var anonymous = function() &#123; return true;&#125;;// 有名函数表达式var named = function named() &#123; return true;&#125;;// 立即调用函数表达式(function() &#123; console.log(&#x27;Welcome to the Internet. Please follow me.&#x27;);&#125;)(); 绝对不要在一个非函数块里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同。 注: ECMA-262定义把块定义为一组语句，函数声明不是一个语句。阅读ECMA-262对这个问题的说明.12345678910111213// badif (currentUser) &#123; function test() &#123; console.log(&#x27;Nope.&#x27;); &#125;&#125;// goodif (currentUser) &#123; var test = function test() &#123; console.log(&#x27;Yup.&#x27;); &#125;;&#125; 绝对不要把参数命名为 arguments, 这将会逾越函数作用域内传过来的 arguments 对象.123456789// badfunction nope(name, options, arguments) &#123; // ...stuff...&#125;// goodfunction yup(name, options, args) &#123; // ...stuff...&#125; 属性 当使用变量和特殊非法变量名时，访问属性时可以使用中括号(. 优先).12345678910var luke = &#123; jedi: true, age: 28&#125;;function getProp(prop) &#123; return luke[prop];&#125;var isJedi = getProp(&#x27;jedi&#x27;); 变量 总是使用 var 来声明变量，如果不这么做将导致产生全局变量，我们要避免污染全局命名空间。12345// badsuperPower = new SuperPower();// goodvar superPower = new SuperPower(); 使用一个 var 以及新行声明多个变量，缩进4个空格。123456789// badvar items = getItems();var goSportsTeam = true;var dragonball = &#x27;z&#x27;;// goodvar items = getItems(), goSportsTeam = true, dragonball = &#x27;z&#x27;; 最后再声明未赋值的变量，当你想引用之前已赋值变量的时候很有用。1234567891011121314151617// badvar i, len, dragonball, items = getItems(), goSportsTeam = true;// badvar i, items = getItems(), dragonball, goSportsTeam = true, len;// goodvar items = getItems(), goSportsTeam = true, dragonball, length, i; 在作用域顶部声明变量，避免变量声明和赋值引起的相关问题。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// badfunction() &#123; test(); console.log(&#x27;doing stuff..&#x27;); //..other stuff.. var name = getName(); if (name === &#x27;test&#x27;) &#123; return false; &#125; return name;&#125;// goodfunction() &#123; var name = getName(); test(); console.log(&#x27;doing stuff..&#x27;); //..other stuff.. if (name === &#x27;test&#x27;) &#123; return false; &#125; return name;&#125;// badfunction() &#123; var name = getName(); if (!arguments.length) &#123; return false; &#125; return true;&#125;// goodfunction() &#123; if (!arguments.length) &#123; return false; &#125; var name = getName(); return true;&#125; 条件表达式和等号 合理使用 === 和 !== 以及 == 和 !=. 合理使用表达式逻辑操作运算. 条件表达式的强制类型转换遵循以下规则： 对象 被计算为 true Undefined 被计算为 false Null 被计算为 false 布尔值 被计算为 布尔的值 数字 如果是 +0, -0, or NaN 被计算为 false , 否则为 true 字符串 如果是空字符串 &#39;&#39; 则被计算为 false, 否则为 true 1234if ([0]) &#123; // true // An array is an object, objects evaluate to true&#125; 使用快捷方式.12345678910111213141516171819// badif (name !== &#x27;&#x27;) &#123; // ...stuff...&#125;// goodif (name) &#123; // ...stuff...&#125;// badif (collection.length &gt; 0) &#123; // ...stuff...&#125;// goodif (collection.length) &#123; // ...stuff...&#125; 阅读 Truth Equality and JavaScript 了解更多 块 给所有多行的块使用大括号12345678910111213141516171819// badif (test) return false;// goodif (test) return false;// goodif (test) &#123; return false;&#125;// badfunction() &#123; return false; &#125;// goodfunction() &#123; return false;&#125; 注释 使用 /** ... */ 进行多行注释，包括描述，指定类型以及参数值和返回值123456789101112131415161718192021222324252627// bad// make() returns a new element// based on the passed in tag name//// @param &lt;String&gt; tag// @return &lt;Element&gt; elementfunction make(tag) &#123; // ...stuff... return element;&#125;// good/** * make() returns a new element * based on the passed in tag name * * @param &lt;String&gt; tag * @return &lt;Element&gt; element */function make(tag) &#123; // ...stuff... return element;&#125; 使用 // 进行单行注释，在评论对象的上面进行单行注释，注释前放一个空行.12345678910111213141516171819202122232425// badvar active = true; // is current tab// good// is current tabvar active = true;// badfunction getType() &#123; console.log(&#x27;fetching type...&#x27;); // set the default type to &#x27;no type&#x27; var type = this._type || &#x27;no type&#x27;; return type;&#125;// goodfunction getType() &#123; console.log(&#x27;fetching type...&#x27;); // set the default type to &#x27;no type&#x27; var type = this._type || &#x27;no type&#x27;; return type;&#125; 如果你有一个问题需要重新来看一下或如果你建议一个需要被实现的解决方法的话需要在你的注释前面加上 FIXME 或 TODO 帮助其他人迅速理解12345678910111213141516function Calculator() &#123; // FIXME: shouldn&#x27;t use a global here total = 0; return this;&#125;function Calculator() &#123; // TODO: total should be configurable by an options param this.total = 0; return this;&#125; 满足规范的文档，在需要文档的时候，可以尝试jsdoc. 空白 缩进、格式化能帮助团队更快得定位修复代码BUG. 将tab设为4个空格1234567891011121314// badfunction() &#123;∙∙var name;&#125;// badfunction() &#123;∙var name;&#125;// goodfunction() &#123;∙∙∙∙var name;&#125; 大括号前放一个空格123456789101112131415161718192021// badfunction test()&#123; console.log(&#x27;test&#x27;);&#125;// goodfunction test() &#123; console.log(&#x27;test&#x27;);&#125;// baddog.set(&#x27;attr&#x27;,&#123; age: &#x27;1 year&#x27;, breed: &#x27;Bernese Mountain Dog&#x27;&#125;);// gooddog.set(&#x27;attr&#x27;, &#123; age: &#x27;1 year&#x27;, breed: &#x27;Bernese Mountain Dog&#x27;&#125;); 在做长方法链时使用缩进.1234567891011121314151617181920212223242526// bad$(&#x27;#items&#x27;).find(&#x27;.selected&#x27;).highlight().end().find(&#x27;.open&#x27;).updateCount();// good$(&#x27;#items&#x27;) .find(&#x27;.selected&#x27;) .highlight() .end() .find(&#x27;.open&#x27;) .updateCount();// badvar leds = stage.selectAll(&#x27;.led&#x27;).data(data).enter().append(&#x27;svg:svg&#x27;).class(&#x27;led&#x27;, true) .attr(&#x27;width&#x27;, (radius + margin) * 2).append(&#x27;svg:g&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + (radius + margin) + &#x27;,&#x27; + (radius + margin) + &#x27;)&#x27;) .call(tron.led);// goodvar leds = stage.selectAll(&#x27;.led&#x27;) .data(data) .enter().append(&#x27;svg:svg&#x27;) .class(&#x27;led&#x27;, true) .attr(&#x27;width&#x27;, (radius + margin) * 2) .append(&#x27;svg:g&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + (radius + margin) + &#x27;,&#x27; + (radius + margin) + &#x27;)&#x27;) .call(tron.led); 逗号 不要将逗号放前面12345678910111213141516171819202122232425// badvar once , upon , aTime;// goodvar once, upon, aTime;// badvar hero = &#123; firstName: &#x27;Bob&#x27; , lastName: &#x27;Parr&#x27; , heroName: &#x27;Mr. Incredible&#x27; , superPower: &#x27;strength&#x27;&#125;;// goodvar hero = &#123; firstName: &#x27;Bob&#x27;, lastName: &#x27;Parr&#x27;, heroName: &#x27;Mr. Incredible&#x27;, superPower: &#x27;strength&#x27;&#125;; 不要加多余的逗号，这可能会在IE下引起错误，同时如果多一个逗号某些ES3的实现会计算多数组的长度。123456789101112131415161718192021// badvar hero = &#123; firstName: &#x27;Kevin&#x27;, lastName: &#x27;Flynn&#x27;,&#125;;var heroes = [ &#x27;Batman&#x27;, &#x27;Superman&#x27;,];// goodvar hero = &#123; firstName: &#x27;Kevin&#x27;, lastName: &#x27;Flynn&#x27;&#125;;var heroes = [ &#x27;Batman&#x27;, &#x27;Superman&#x27;]; 分号 语句结束一定要加分号1234567891011121314151617// bad(function() &#123; var name = &#x27;Skywalker&#x27; return name&#125;)()// good(function() &#123; var name = &#x27;Skywalker&#x27;; return name;&#125;)();// good;(function() &#123; var name = &#x27;Skywalker&#x27;; return name;&#125;)(); 类型转换 在语句的开始执行类型转换. 字符串:12345678910111213// =&gt; this.reviewScore = 9;// badvar totalScore = this.reviewScore + &#x27;&#x27;;// goodvar totalScore = &#x27;&#x27; + this.reviewScore;// badvar totalScore = &#x27;&#x27; + this.reviewScore + &#x27; total score&#x27;;// goodvar totalScore = this.reviewScore + &#x27; total score&#x27;; 对数字使用 parseInt 并且总是带上类型转换的基数.，如parseInt(value, 10)123456789101112131415161718192021222324252627var inputValue = &#x27;4&#x27;;// badvar val = new Number(inputValue);// badvar val = +inputValue;// badvar val = inputValue &gt;&gt; 0;// badvar val = parseInt(inputValue);// goodvar val = Number(inputValue);// goodvar val = parseInt(inputValue, 10);// good/** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */var val = inputValue &gt;&gt; 0; 布尔值:12345678910var age = 0;// badvar hasAge = new Boolean(age);// goodvar hasAge = Boolean(age);// goodvar hasAge = !!age; 命名约定 避免单个字符名，让你的变量名有描述意义。123456789// badfunction q() &#123; // ...stuff...&#125;// goodfunction query() &#123; // ..stuff..&#125; 当命名对象、函数和实例时使用驼峰命名规则123456789101112131415// badvar OBJEcttsssss = &#123;&#125;;var this_is_my_object = &#123;&#125;;var this-is-my-object = &#123;&#125;;function c() &#123;&#125;;var u = new user(&#123; name: &#x27;Bob Parr&#x27;&#125;);// goodvar thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125;;var user = new User(&#123; name: &#x27;Bob Parr&#x27;&#125;); 当命名构造函数或类时使用驼峰式大写1234567891011121314151617// badfunction user(options) &#123; this.name = options.name;&#125;var bad = new user(&#123; name: &#x27;nope&#x27;&#125;);// goodfunction User(options) &#123; this.name = options.name;&#125;var good = new User(&#123; name: &#x27;yup&#x27;&#125;); 命名私有属性时前面加个下划线 _123456// badthis.__firstName__ = &#x27;Panda&#x27;;this.firstName_ = &#x27;Panda&#x27;;// goodthis._firstName = &#x27;Panda&#x27;; 当保存对 this 的引用时使用 self(python 风格),避免this issue . Angular建议使用vm(MVVM模式中view-model)1234567// goodfunction() &#123; var self = this; return function() &#123; console.log(self); &#125;;&#125; 存取器 属性的存取器函数不是必需的 如果你确实有存取器函数的话使用getVal() 和 setVal(‘hello’),java getter、setter风格或者jQuery风格 如果属性是布尔值，使用isVal() 或 hasVal()123456789// badif (!dragon.age()) &#123; return false;&#125;// goodif (!dragon.hasAge()) &#123; return false;&#125; 可以创建get()和set()函数，但是要保持一致12345678910111213function Jedi(options) &#123; options || (options = &#123;&#125;); var lightsaber = options.lightsaber || &#x27;blue&#x27;; this.set(&#x27;lightsaber&#x27;, lightsaber);&#125;Jedi.prototype.set = function(key, val) &#123; this[key] = val;&#125;;Jedi.prototype.get = function(key) &#123; return this[key];&#125;; 构造器 给对象原型分配方法，而不是用一个新的对象覆盖原型，覆盖原型会使继承出现问题。1234567891011121314151617181920212223function Jedi() &#123; console.log(&#x27;new jedi&#x27;);&#125;// badJedi.prototype = &#123; fight: function fight() &#123; console.log(&#x27;fighting&#x27;); &#125;, block: function block() &#123; console.log(&#x27;blocking&#x27;); &#125;&#125;;// goodJedi.prototype.fight = function fight() &#123; console.log(&#x27;fighting&#x27;);&#125;;Jedi.prototype.block = function block() &#123; console.log(&#x27;blocking&#x27;);&#125;; 方法可以返回 this 帮助方法可链。1234567891011121314151617181920212223242526272829// badJedi.prototype.jump = function() &#123; this.jumping = true; return true;&#125;;Jedi.prototype.setHeight = function(height) &#123; this.height = height;&#125;;var luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20) // =&gt; undefined// goodJedi.prototype.jump = function() &#123; this.jumping = true; return this;&#125;;Jedi.prototype.setHeight = function(height) &#123; this.height = height; return this;&#125;;var luke = new Jedi();luke.jump() .setHeight(20); 可以写一个自定义的toString()方法，但是确保它工作正常并且不会有副作用。123456789101112function Jedi(options) &#123; options || (options = &#123;&#125;); this.name = options.name || &#x27;no name&#x27;;&#125;Jedi.prototype.getName = function getName() &#123; return this.name;&#125;;Jedi.prototype.toString = function toString() &#123; return &#x27;Jedi - &#x27; + this.getName();&#125;; 事件 当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面的贡献者加入更多数据到事件数据里而不用找出并更新那个事件的事件处理器123456789101112131415161718// bad$(this).trigger(&#x27;listingUpdated&#x27;, listing.id);...$(this).on(&#x27;listingUpdated&#x27;, function(e, listingId) &#123; // do something with listingId&#125;);// good$(this).trigger(&#x27;listingUpdated&#x27;, &#123; listingId : listing.id &#125;);...$(this).on(&#x27;listingUpdated&#x27;, function(e, data) &#123; // do something with data.listingId&#125;); 模块 这个文件应该以驼峰命名，并在同名文件夹下，同时导出的时候名字一致 对于公开API库可以考虑加入一个名为noConflict()的方法来设置导出的模块为之前的版本并返回它 总是在模块顶部声明 &#39;use strict&#39;;，引入JSHint规范123456789101112131415161718// fancyInput/fancyInput.js（function(global) &#123; &#x27;use strict&#x27;; var previousFancyInput = global.FancyInput; function FancyInput(options) &#123; this.options = options || &#123;&#125;; &#125; FancyInput.noConflict = function noConflict() &#123; global.FancyInput = previousFancyInput; return FancyInput; &#125;; global.FancyInput = FancyInput;&#125;)(this); jQuery 对于jQuery对象以$开头，以和原生DOM节点区分。12345// badvar menu = $(&quot;.menu&quot;);// goodvar $menu = $(&quot;.menu&quot;); 缓存jQuery查询12345678910111213141516171819202122// badfunction setSidebar() &#123; $(&#x27;.sidebar&#x27;).hide(); // ...stuff... $(&#x27;.sidebar&#x27;).css(&#123; &#x27;background-color&#x27;: &#x27;pink&#x27; &#125;);&#125;// goodfunction setSidebar() &#123; var $sidebar = $(&#x27;.sidebar&#x27;); $sidebar.hide(); // ...stuff... $sidebar.css(&#123; &#x27;background-color&#x27;: &#x27;pink&#x27; &#125;);&#125; 对DOM查询使用级联的 $(&#39;.sidebar ul&#39;) 或 $(&#39;.sidebar ul&#39;)，jsPerf 对有作用域的jQuery对象查询使用 find1234567891011121314151617// bad$(&#x27;.sidebar&#x27;, &#x27;ul&#x27;).hide();// bad$(&#x27;.sidebar&#x27;).find(&#x27;ul&#x27;).hide();// good$(&#x27;.sidebar ul&#x27;).hide();// good$(&#x27;.sidebar &gt; ul&#x27;).hide();// good (slower)$sidebar.find(&#x27;ul&#x27;);// good (faster)$($sidebar[0]).find(&#x27;ul&#x27;); 每个页面只使用一次document的ready事件，这样便于调试与行为流跟踪。123$(function()&#123; //do your page init. &#125;); 事件利用jQuery.on从页面分离到JavaScript文件。1234567// bad&lt;a id=&quot;myLink&quot; href=&quot;#&quot; onclick=&quot;myEventHandler();&quot;&gt;&lt;/a&gt;// good&lt;a id=&quot;myLink&quot; href=&quot;#&quot;&gt;&lt;/a&gt;$(&quot;#myLink&quot;).on(&quot;click&quot;, myEventHandler); 对于Ajax使用promise方式。1234567891011121314151617// bad$.ajax(&#123; ... success : function()&#123; &#125;, error : function()&#123; &#125; &#125;)// good$.ajax(&#123;. ..&#125;).then( function( )&#123; // success&#125;, function( )&#123; // error&#125;) 利用promise的deferred对象解决延迟注册问题。123456789var dtd = $.Deferred(); // 新建一个deferred对象var wait = function(dtd)&#123; var tasks = function()&#123; alert(&quot;执行完毕！&quot;); dtd.resolve(); // 改变deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd;&#125;; HTML中Style、以及JavaScript中style移到CSS中class，在HTML、JavaScript中引入class，而不是直接style。 ECMAScript 5兼容性尽量采用ES5方法，特别数组map、filter、forEach方法简化日常开发。在老式IE浏览器中引入ES5-shim。或者也可以考虑引入underscore、lodash 常用辅助库. 参考Kangax的 ES5 compatibility table HTML、CSS、JavaScript分离 页面DOM结构使用HTML，样式则采用CSS，动态DOM操作JavaScript。不要混用在HTML中分离在不同类型文件，文件link。 HTML、CSS、JavaScript变量名都需要有业务价值。CSS以中划线分割的全小写命名，JavaScript则首字母小写的驼峰命名。 CSS可引入Bootstrap、Foundation等出名响应式设计框架。以及SASS、LESS工具书写CSS。 对于CSS、JavaScript建议合并为单文件，减少Ajax的连接数。也可以引入AMD(Require.js)加载方式。 对于内部大部分企业管理系统，可以尝试采用前端 MVC框架组织代码。如Angular、React + flux架构、Knockout等。 对于兼容性可用Modernizr规范库辅助。 使用jsHint 前端项目中推荐引入 jshint插件来规范项目编码规范。以及一套完善的IDE配置。 注意：jshint需要引入nodejs 工具grunt或gulp插件，建议企业级nodejs npm私服。 前端工具 前端第三方JavaScript包管理工具bower(bower install jQuery)，bower可以实现第三方库的依赖解析、下载、升级管理等。建议建立企业级bower私服。 前端构建工具，可以采用grunt或者gulp工具，可以实现html、css、js压缩、验证、测试，文件合并、watch和liveload等所有前端任务。建议企业级nodejs npm私服。 前端开发IDE： WebStorm( Idea )、Sublime为最佳 。项目组统一IDE。IDE统一配置很重要。 本文转载自破狼,原文略有修改,侵权即删.原文链接：前端javascript规范原文作者：破狼","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ioliu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ioliu.cn/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"https://ioliu.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"规范","slug":"规范","permalink":"https://ioliu.cn/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"你可能不知道的一些JavaScript 奇技淫巧","slug":"about-javascript-spcial-technique","date":"2015-05-07T02:21:08.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2015/about-javascript-spcial-technique/","permalink":"https://ioliu.cn/2015/about-javascript-spcial-technique/","excerpt":"","text":"这里记录一下以前学习各种书籍和文章里边出现的JS的小技巧，分享给大家，也供自己查阅，同时感谢那些发现创造和分享这些技巧的前辈和大牛们。 ## 遍历一个obj的属性到数组 1234567function getAttr(obj)&#123; var a=[]; for(a[a.length] in obj); return a;&#125;console.log(getAttr(&#123;&#x27;name&#x27;:&#x27;zhangsan&#x27;,&#x27;age&#x27;:&#x27;20&#x27;&#125;));//输出:[&#x27;name&#x27;,&#x27;age&#x27;] 乍一看可能比较蒙，不过仔细分析还是不难理解的。常见用法是`for(var key in obj)`，这里`key`初始也是`undefined`的，`a[a.length]`整体也是`undefined`，所以二者其实是等价的。 在`for`循环中，`obj`的属性会依次赋值给`key`，同样，也依次赋值给`a[a.length]`，这里`length`一直在变，就巧妙地挨个赋值给数组的每一个元素了。 重复字符串(如abc=&gt;abcabc)123function repeat(target,n)&#123; return (new Array(n+1).join(target));&#125; 改进版本: 1234function repeat(target,n)&#123; return Array.prototype.join.call(&#123;length:n+1&#125;,target); //之所以要创建带length属性的对象，是因为调用数组原型方法时，必须是一个类数组对象，而类数组对象的条件就是length为非负整数&#125; 不新建数组，而是用拥有length属性的对象替代，然后调用数组的join方法,性能提升很大.再改进： 1234567var repeat=(function()&#123; var join=Array.prototype.join,obj=&#123;&#125;; return function(target,n)&#123; obj.length=n+1; return join.call(obj,target); &#125;&#125;)(); 利用闭包将对象和join方法缓存起来，不用每次都新建对象和寻找方法 for循环for循环中，当第二项为false时会终止循环，这里并不一定存在比较，可以直接赋值，如果赋值为undefined之类的值时，转成bool值也为假，因此也会终止，比如遍历数组可以写成： 1for(var i=arr.length,element;element=arr[—-i];)&#123;…&#125; 这里，第二项一定是arr[--i]而非arr[i--],如果是后者的话，上来就是undefined，就不会执行循环体，或者for(var i=0,element;element=arr[i++];)&#123;…&#125; NaNNaN是JS中唯一不等于自己的值，因此可以用来判断一个变量是否真的为NaN:a!==a /、+等算术运算符&lt;&#x2F;+等运算符会强制符号两边的表达式执行valueOf然后比较，所以如果两边是函数或者对象，而又重写了该对象的valueOf方法，就会自动执行两边的方法。如： 12var a=&#123;valueOf:function()&#123;console.log(&quot;aaa&quot;);&#125;&#125;,b=&#123;valueOf:function()&#123;console.log(&quot;bbb&quot;);&#125;&#125;; a &lt; b;//会输出:aaa;bbb;false 闭包理解闭包需学会三个基本事实： JS允许你引用在当前函数意外定义的变量 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量。这是因为JS的函数值包含里比调用它们时执行所需要的代码更多的信息 闭包可以更新外部变量的值。这是因为闭包存储的是外部变量的引用而非值副本。如：1234567891011function box()&#123; var val=undefined; return &#123; set:function(x)&#123;val=x;&#125;, get:function()&#123;return val;&#125; &#125;;&#125;var b=box();b.get();//“undefined”b.set(5);b.get();//5 这一点很重要，比如在函数的for循环体内返回闭包或者有闭包取for循环的计数器值，那么这个闭包取到的永远是for循环结束时i的最终值，因为闭包存储的是它的引用而非当时的值副本。 块级作用域JS没有块级作用域，因此通常情况下函数内部的所有变量都是绑定到函数作用域的，也就是说相当于都在函数一开始就声明了的，一个例外就是try/catch中的变量是块级的，只属于try/catch块。 嵌套函数众所周知，在函数内部声明函数是可以的，但是在在函数内的局部块里声明，可能会出现问题： 123456789101112function f()&#123;return “global”;&#125;function test(x)&#123; function f()&#123;return “local”&#125; var result=[]; if(x)&#123; result.push(f()); &#125; result.push(f()); return result;&#125;test(true);//[“local”,”local”]test(false);//[“local”] 将函数声明到if块中： 123456789101112function f()&#123;return “global”;&#125;function test(x)&#123; var result=[]; if(x)&#123; function f()&#123;return “local”&#125; result.push(f()); &#125; result.push(f()); return result;&#125; test(true);//?test(false);//? 结果会如何呢？理论上讲，JS没有块级作用域，因此f()的作用域是整个test函数，因此合理猜测应该是与上一次输出相同，全部为”local”，可是并不是所有的JS执行环境都如此行事，有的会根据是否执行包含f的代码块来有条件地绑定函数f（绑定即意味着将该变量绑定到其最近的作用域，而赋值是发生在代码实际执行到赋值那一步的时候进行的）。因此最好的办法是如果要声明嵌套函数，都在其富函数的最外层声明，要么就不要声明函数，而是使用var声明和函数表达式来实现： 12345678910function f()&#123;return “global”;&#125;function test(x)&#123; var result=[]; if(x)&#123; var g=function()&#123;return “local”&#125; result.push(g()); &#125; result.push(f()); return result;&#125; hasOwnProperty用js创建字典的时候，如果是利用对象的方式（因为JS对象的核心是一个字符串属性名称和属性值的映射表），会遇到一个问题就是原型污染，因为获取字典属性值的时候用hasOwnProperty还好，如果用for in遍历的话，不仅会遍历对象本身，包括它的原型，因此如果在其他地方污染了Object的原型，那么for in就会产生非预期的结果，这时可能会用hasOwnProperty来先检测该对象本身是否含有属性来避免原型污染，然而更极端的情况是连hasOwnProperty这个原型方法都有可能被污染。避免原型污染的方法是在创建字典对象的时候用Object.create(null)来创建一个完全空对象，这个对象没有原型，这个方法是ES5的,在没有这个方法可用的时候，最好是创建字典类，然后在字典类里用数组来存储有序集合，自己维护这个集合。 类数组对象JS中的类数组对象可以享用数组的大部分原型方法如map等类数组对象是指满足两个条件的对象： 一是具备合理范围值内的length属性 二是length属性大于该对象的最大索引，索引是一个合理范围的证书，它的字符串表示的是对象的一个key；但是数组的一个原型方法contact是不能被类数组对象调用的，因此需要先用[].slice.call把类数组对象转换为真正的数组比如[].slice.call(arguments)。 结构类型并不是所有时候都需要继承，继承也不是完美的，有时候会创造比他能解决的更多的问题，特别是当层次关系没那么明显的时候，这时候应该多用结构类型(又叫鸭子类型，如果它看起来像鸭子、游泳像鸭子并且叫声像鸭子，那么它就是鸭子)，用结构类型设计灵活的对象接口的时候，不需要创建类工厂来返回类的实例，而是直接返回对象，对象具备预期的方法和属性，比如： 1234567SomeObj.someWidget=function(opts)&#123; return &#123; a:blabla, b:function()&#123;...&#125;, c:blabla &#125;&#125; JavaScript 自动插入分号JavaScript 具备自动插入分号的能力，但是自动插入分号并不是万能的，其有三条规则： 只在&#125;标记之前、一个或多个换行之后以及程序输入的结尾被插入 分号只在随后的输入标记不能被解析时插入 !!这一点很重要,比如: a &#x3D; b (fn()); 是不会在a=b之后自动插入分号的，因为a=b(f())是可以被解析的，因此像(,[,+,-,/开头的时候，需要特别注意上一行可能不会自动插入。 还有一些情况，尽管不会出现解析错误，JS仍然会强制插入分号，这就是所谓的JS语法限制产生式。它不允许在两个字符间出现换行，最危险的就是return语句，如 return{}; 会被强制插入而成为 return;{}; 类似的还有：throw语句、带有显示标签的break或着continue语句、后置自增或自减运算符 分号不会作为分隔符在for循环空语句的头部被自动插入 因此，最好的办法是在自己的js文件的最开始防御性地插入;，这样在合并js文件的时候就不会出问题了。 本文转载自博客园,原文略有删减,侵权即删.原文链接：你可能不知道的一些JavaScript 奇技淫巧原文作者：FirstLovt","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ioliu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ioliu.cn/tags/JavaScript/"},{"name":"JavaScript技巧","slug":"JavaScript技巧","permalink":"https://ioliu.cn/tags/JavaScript%E6%8A%80%E5%B7%A7/"},{"name":"结构类型","slug":"结构类型","permalink":"https://ioliu.cn/tags/%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B/"},{"name":"数组遍历","slug":"数组遍历","permalink":"https://ioliu.cn/tags/%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86/"},{"name":"前端","slug":"前端","permalink":"https://ioliu.cn/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Hello World for Hexo","slug":"hexo-your-blog","date":"2015-05-06T02:21:08.000Z","updated":"2024-03-26T13:23:43.422Z","comments":true,"path":"2015/hexo-your-blog/","permalink":"https://ioliu.cn/2015/hexo-your-blog/","excerpt":"","text":"今天把博客移到了Hexo,感觉蛮不错的 ^_^ . 简介hexo 是一款基于Node.js的静态博客框架。目前在GitHub上已有4k+ star 和 700+ fork (官网)。是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 特性 风一般的速度: Hexo基于Node.js，支持多进程，几百篇文章也可以秒生成。 流畅的撰写: 支持GitHub Flavored Markdown和所有Octopress的插件。 扩展性: Hexo支持EJS、Swig和Stylus。通过插件支持Haml、Jade和Less. 快速入门安装安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1npm install -g hexo-cli 仅需一步就把 Hexo 本体和所有相依套件安装完毕，很简单吧？ 升级更新hexo到最新版 1npm update hexo -g 初始化123hexo init &lt;folder&gt;cd &lt;floder&gt;npm install 如果指定 &lt;folder&gt;，便会在目前的资料夹建立一个名为 &lt;folder&gt; 的新文件夹；否则会在目前文件夹初始化。 新建1hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 生成静态文件12hexo g//或者 hexo generate 启动服务12hexo s//或者 hexo server 启动服务后,打开浏览器输入 http://localhost:4000 回车,即可看到效果. 部署12hexo d//可以通过hexo d -g 命令完成生成和部署 如果出现错误，可能是没有安装部署插件，请执行下面的命令安装插件： 1npm install hexo-deploy-git --save-dev Hexo官网：[http://Hexo.io]部署Hexo","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ioliu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://ioliu.cn/tags/Hexo/"},{"name":"免费博客","slug":"免费博客","permalink":"https://ioliu.cn/tags/%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://ioliu.cn/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"其他","slug":"其他","permalink":"https://ioliu.cn/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"bbr","slug":"bbr","permalink":"https://ioliu.cn/tags/bbr/"},{"name":"linux","slug":"linux","permalink":"https://ioliu.cn/tags/linux/"},{"name":"Git","slug":"Git","permalink":"https://ioliu.cn/tags/Git/"},{"name":"Command","slug":"Command","permalink":"https://ioliu.cn/tags/Command/"},{"name":"Valine","slug":"Valine","permalink":"https://ioliu.cn/tags/Valine/"},{"name":"Comment System","slug":"Comment-System","permalink":"https://ioliu.cn/tags/Comment-System/"},{"name":"评论系统","slug":"评论系统","permalink":"https://ioliu.cn/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"},{"name":"国家/地区","slug":"国家-地区","permalink":"https://ioliu.cn/tags/%E5%9B%BD%E5%AE%B6-%E5%9C%B0%E5%8C%BA/"},{"name":"语言缩写","slug":"语言缩写","permalink":"https://ioliu.cn/tags/%E8%AF%AD%E8%A8%80%E7%BC%A9%E5%86%99/"},{"name":"MySql","slug":"MySql","permalink":"https://ioliu.cn/tags/MySql/"},{"name":"数据库","slug":"数据库","permalink":"https://ioliu.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"ssl","slug":"ssl","permalink":"https://ioliu.cn/tags/ssl/"},{"name":"cerbot","slug":"cerbot","permalink":"https://ioliu.cn/tags/cerbot/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ioliu.cn/tags/JavaScript/"},{"name":"前端","slug":"前端","permalink":"https://ioliu.cn/tags/%E5%89%8D%E7%AB%AF/"},{"name":"变量类型","slug":"变量类型","permalink":"https://ioliu.cn/tags/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"name":"CSS","slug":"CSS","permalink":"https://ioliu.cn/tags/CSS/"},{"name":"译文","slug":"译文","permalink":"https://ioliu.cn/tags/%E8%AF%91%E6%96%87/"},{"name":"技巧","slug":"技巧","permalink":"https://ioliu.cn/tags/%E6%8A%80%E5%B7%A7/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://ioliu.cn/tags/MarkDown/"},{"name":"Guide","slug":"Guide","permalink":"https://ioliu.cn/tags/Guide/"},{"name":"Media Query","slug":"Media-Query","permalink":"https://ioliu.cn/tags/Media-Query/"},{"name":"响应式","slug":"响应式","permalink":"https://ioliu.cn/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"媒体查询","slug":"媒体查询","permalink":"https://ioliu.cn/tags/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/"},{"name":"GitHub","slug":"GitHub","permalink":"https://ioliu.cn/tags/GitHub/"},{"name":"SSH Key","slug":"SSH-Key","permalink":"https://ioliu.cn/tags/SSH-Key/"},{"name":"免密码","slug":"免密码","permalink":"https://ioliu.cn/tags/%E5%85%8D%E5%AF%86%E7%A0%81/"},{"name":"规范","slug":"规范","permalink":"https://ioliu.cn/tags/%E8%A7%84%E8%8C%83/"},{"name":"JavaScript技巧","slug":"JavaScript技巧","permalink":"https://ioliu.cn/tags/JavaScript%E6%8A%80%E5%B7%A7/"},{"name":"结构类型","slug":"结构类型","permalink":"https://ioliu.cn/tags/%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B/"},{"name":"数组遍历","slug":"数组遍历","permalink":"https://ioliu.cn/tags/%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86/"},{"name":"Hexo","slug":"Hexo","permalink":"https://ioliu.cn/tags/Hexo/"},{"name":"免费博客","slug":"免费博客","permalink":"https://ioliu.cn/tags/%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2/"}]}